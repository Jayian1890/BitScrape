#include "dht_hunter/metadata/bt_connection.hpp"
#include "dht_hunter/logforge/logforge.hpp"

namespace dht_hunter::metadata {

BTConnection::BTConnection(std::unique_ptr<network::AsyncSocket> socket,
                           const std::array<uint8_t, BT_INFOHASH_LENGTH>& infoHash,
                           BTConnectionStateCallback stateCallback,
                           BTMetadataCallback metadataCallback,
                           const std::string& peerIdPrefix,
                           const std::string& clientVersion)
    : m_socket(std::move(socket)),
      m_state(BTConnectionState::Disconnected),
      m_infoHash(infoHash),
      m_peerId(generatePeerId(peerIdPrefix)),
      m_stateCallback(stateCallback),
      m_metadataCallback(metadataCallback),
      m_clientVersion(clientVersion),
      m_receiveBuffer(BT_RECEIVE_BUFFER_SIZE),
      m_receiveBufferPos(0),
      m_metadataSize(0),
      m_metadataPiecesRequested(0),
      m_receivedPieceCount(0) {
    // Initialize the extension protocol and ut_metadata handlers
    m_extensionProtocol.setClientVersion(m_clientVersion);
    m_utMetadata.setInfoHash(m_infoHash);
}

BTConnection::~BTConnection() {
    disconnect();
}

bool BTConnection::connect(const network::EndPoint& endpoint) {
    m_remoteEndpoint = endpoint;
    setState(BTConnectionState::Connecting);
    
    // Use the new callback style that matches the AsyncSocket API
    return m_socket->connect(endpoint, [this](bool success) {
        if (success) {
            setState(BTConnectionState::Connected, "Connected successfully");
            sendHandshake();
        } else {
            setState(BTConnectionState::Error, "Connection failed");
        }
    });
}

void BTConnection::disconnect() {
    if (m_socket) {
        m_socket->close();
    }
    
    setState(BTConnectionState::Disconnected);
}

BTConnectionState BTConnection::getState() const {
    return m_state;
}

const std::array<uint8_t, BT_INFOHASH_LENGTH>& BTConnection::getInfoHash() const {
    return m_infoHash;
}

const std::array<uint8_t, BT_PEER_ID_LENGTH>& BTConnection::getPeerId() const {
    return m_peerId;
}

const network::EndPoint& BTConnection::getRemoteEndpoint() const {
    return m_remoteEndpoint;
}

std::string BTConnection::getPeerClientVersion() const {
    return m_extensionProtocol.getPeerClientVersion();
}

void BTConnection::setState(BTConnectionState state, const std::string& error) {
    if (m_state != state) {
        m_state = state;
        
        if (m_stateCallback) {
            m_stateCallback(state, error);
        }
    }
}

void BTConnection::onConnect(network::Socket* socket, network::SocketError error) {
    // This method is now unused since we're using the new callback style
    if (error == network::SocketError::None) {
        setState(BTConnectionState::Connected, "Connected successfully");
        sendHandshake();
    } else {
        setState(BTConnectionState::Error, "Connection failed");
    }
}

void BTConnection::sendHandshake() {
    // Create a handshake message
    BTHandshake handshake(m_infoHash, m_peerId, true);
    std::vector<uint8_t> handshakeData = handshake.serialize();
    
    // Send the handshake
    std::shared_ptr<network::Buffer> buffer = std::make_shared<network::Buffer>(handshakeData.size());
    std::memcpy(buffer->data(), handshakeData.data(), handshakeData.size());
    buffer->resize(handshakeData.size());
    
    setState(BTConnectionState::HandshakeSent);
    
    m_socket->send(buffer, [this](bool success, int bytesSent) {
        if (!success) {
            setState(BTConnectionState::Error, "Failed to send handshake");
        } else {
            // Start reading the response
            readNextMessage();
        }
    });
}

void BTConnection::onWrite(network::Socket* socket, int size, network::SocketError error) {
    // This method is now unused since we're using the new callback style
}

void BTConnection::onRead(network::Socket* socket, const uint8_t* data, int size, network::SocketError error) {
    // This method is now unused since we're using the new callback style
}

void BTConnection::processHandshake() {
    // Simplified implementation
    if (m_receiveBufferPos >= BT_HANDSHAKE_LENGTH) {
        BTHandshake handshake;
        if (handshake.deserialize(m_receiveBuffer.data(), m_receiveBufferPos)) {
            setState(BTConnectionState::HandshakeReceived);
            
            // Check if the peer supports the extension protocol
            if (handshake.supportsExtensionProtocol()) {
                sendExtensionHandshake();
            } else {
                setState(BTConnectionState::Error, "Peer does not support extension protocol");
            }
        } else {
            setState(BTConnectionState::Error, "Invalid handshake received");
        }
        
        // Clear the buffer
        m_receiveBufferPos = 0;
    }
}

void BTConnection::sendExtensionHandshake() {
    // Create an extension handshake message
    std::vector<uint8_t> extensionMessage = m_extensionProtocol.createHandshake();
    
    // Send the extension handshake
    std::shared_ptr<network::Buffer> buffer = std::make_shared<network::Buffer>(extensionMessage.size());
    std::memcpy(buffer->data(), extensionMessage.data(), extensionMessage.size());
    buffer->resize(extensionMessage.size());
    
    setState(BTConnectionState::ExtensionHandshakeSent);
    
    m_socket->send(buffer, [this](bool success, int bytesSent) {
        if (!success) {
            setState(BTConnectionState::Error, "Failed to send extension handshake");
        }
    });
}

void BTConnection::processMessage() {
    // Simplified implementation - would parse and handle BitTorrent messages
}

void BTConnection::processExtensionMessage(const uint8_t* data, size_t length) {
    // Simplified implementation - would handle extension protocol messages
}

void BTConnection::requestMetadataPieces() {
    // Simplified implementation - would request metadata pieces
}

void BTConnection::handleMetadataPiece(uint32_t piece, const uint8_t* data, uint32_t size, uint32_t totalSize) {
    // Simplified implementation - would handle received metadata pieces
}

std::vector<uint8_t> BTConnection::handleMetadataRequest(uint32_t piece) {
    // Simplified implementation - would handle metadata requests from peers
    return {};
}

void BTConnection::handleMetadataReject(uint32_t piece) {
    // Simplified implementation - would handle metadata rejection
}

bool BTConnection::isMetadataComplete() const {
    // Simplified implementation - would check if all metadata pieces have been received
    return false;
}

std::vector<uint8_t> BTConnection::assembleMetadata() const {
    // Simplified implementation - would assemble the complete metadata
    return {};
}

bool BTConnection::validateMetadata(const std::vector<uint8_t>& metadata) const {
    // Simplified implementation - would validate the metadata against the info hash
    return false;
}

void BTConnection::readNextMessage() {
    // Use the new callback style that matches the AsyncSocket API
    m_socket->receive(m_receiveBuffer.size() - m_receiveBufferPos, 
        [this](bool success, std::shared_ptr<network::Buffer> buffer, int bytesReceived) {
            if (success && bytesReceived > 0) {
                // Copy data to our buffer
                if (m_receiveBufferPos + bytesReceived <= m_receiveBuffer.size()) {
                    std::memcpy(m_receiveBuffer.data() + m_receiveBufferPos, buffer->data(), bytesReceived);
                    m_receiveBufferPos += bytesReceived;
                    
                    // Process the received data
                    if (m_state == BTConnectionState::HandshakeSent) {
                        processHandshake();
                    } else {
                        processMessage();
                    }
                } else {
                    setState(BTConnectionState::Error, "Receive buffer overflow");
                }
                
                // Continue reading
                readNextMessage();
            } else if (!success) {
                setState(BTConnectionState::Error, "Read failed");
            }
        });
}

} // namespace dht_hunter::metadata
