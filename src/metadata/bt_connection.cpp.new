#include "dht_hunter/metadata/bt_connection.hpp"
#include "dht_hunter/logforge/logforge.hpp"

namespace dht_hunter {
namespace metadata {

BTConnection::BTConnection(std::unique_ptr<network::AsyncSocket> socket,
                           const InfoHash& infoHash,
                           StateChangeCallback stateCallback,
                           MetadataCallback metadataCallback,
                           const std::string& peerIdPrefix,
                           const std::string& clientVersion)
    : m_socket(std::move(socket)),
      m_infoHash(infoHash),
      m_stateCallback(stateCallback),
      m_metadataCallback(metadataCallback),
      m_peerIdPrefix(peerIdPrefix),
      m_clientVersion(clientVersion),
      m_state(BTConnectionState::Disconnected),
      m_receiveBuffer(RECEIVE_BUFFER_SIZE),
      m_receiveBufferPos(0),
      m_metadataSize(0),
      m_metadataPieces(0),
      m_metadataReceived(0),
      m_utMetadataId(-1),
      m_extensionHandshakeReceived(false),
      m_handshakeReceived(false),
      m_handshakeSent(false) {
    // Generate a random peer ID with the specified prefix
    m_peerId = m_peerIdPrefix;
    while (m_peerId.size() < 20) {
        m_peerId.push_back(static_cast<char>(rand() % 256));
    }
}

BTConnection::~BTConnection() {
    disconnect();
}

logforge::Logger BTConnection::getLogger() const {
    return logforge::LogForge::getLogger("BTConnection");
}

bool BTConnection::connect(const network::EndPoint& endpoint) {
    // Fixed version with correct callback signature
    if (!m_socket->connect(endpoint, [this](bool success) {
        // Handle connection result
        if (success) {
            // Connection successful
            this->setState(BTConnectionState::Connected, "Connected successfully");
            this->sendHandshake();
        } else {
            // Connection failed
            this->setState(BTConnectionState::Error, "Connection failed");
        }
    })) {
        getLogger()->error("Failed to connect to {}: {}", endpoint.toString(), "Connection failed");
        return false;
    }

    return true;
}

void BTConnection::disconnect() {
    if (m_socket) {
        m_socket->close();
    }
    
    setState(BTConnectionState::Disconnected, "Disconnected");
}

void BTConnection::setState(BTConnectionState state, const std::string& message) {
    if (m_state != state) {
        m_state = state;
        
        if (m_stateCallback) {
            m_stateCallback(state, message);
        }
    }
}

void BTConnection::onConnect(network::Socket* socket, network::SocketError error) {
    // This method is now unused since we're using the new callback style
    if (error == network::SocketError::None) {
        setState(BTConnectionState::Connected, "Connected successfully");
        sendHandshake();
    } else {
        setState(BTConnectionState::Error, "Connection failed: " + std::to_string(static_cast<int>(error)));
    }
}

void BTConnection::sendHandshake() {
    if (m_handshakeSent) {
        return;
    }
    
    // Prepare handshake data
    std::vector<uint8_t> handshakeData;
    handshakeData.reserve(68);
    
    // Protocol name length (1 byte)
    handshakeData.push_back(19);
    
    // Protocol name (19 bytes)
    const std::string protocolName = "BitTorrent protocol";
    handshakeData.insert(handshakeData.end(), protocolName.begin(), protocolName.end());
    
    // Reserved bytes (8 bytes)
    uint8_t reserved[8] = {0};
    reserved[5] = 0x10; // Extended messaging protocol
    handshakeData.insert(handshakeData.end(), reserved, reserved + 8);
    
    // Info hash (20 bytes)
    handshakeData.insert(handshakeData.end(), m_infoHash.begin(), m_infoHash.end());
    
    // Peer ID (20 bytes)
    handshakeData.insert(handshakeData.end(), m_peerId.begin(), m_peerId.end());
    
    // Send the handshake
    std::shared_ptr<network::Buffer> buffer = std::make_shared<network::Buffer>(handshakeData.size());
    std::memcpy(buffer->data(), handshakeData.data(), handshakeData.size());
    buffer->resize(handshakeData.size());
    
    m_socket->send(buffer, [this](bool success, int bytesSent) {
        if (success) {
            m_handshakeSent = true;
            readNextMessage();
        } else {
            setState(BTConnectionState::Error, "Failed to send handshake");
        }
    });
}

void BTConnection::onWrite(network::Socket* socket, int size, network::SocketError error) {
    // This method is now unused since we're using the new callback style
    if (error == network::SocketError::None) {
        if (!m_handshakeSent) {
            m_handshakeSent = true;
            readNextMessage();
        }
    } else {
        setState(BTConnectionState::Error, "Write failed: " + std::to_string(static_cast<int>(error)));
    }
}

void BTConnection::onRead(network::Socket* socket, const uint8_t* data, int size, network::SocketError error) {
    // This method is now unused since we're using the new callback style
    if (error == network::SocketError::None) {
        if (size > 0) {
            // Copy data to our buffer
            if (m_receiveBufferPos + size <= m_receiveBuffer.size()) {
                std::memcpy(m_receiveBuffer.data() + m_receiveBufferPos, data, size);
                m_receiveBufferPos += size;
                
                // Process the received data
                if (!m_handshakeReceived) {
                    processHandshake();
                } else {
                    processMessage();
                }
            } else {
                setState(BTConnectionState::Error, "Receive buffer overflow");
            }
        }
        
        // Continue reading
        readNextMessage();
    } else {
        setState(BTConnectionState::Error, "Read failed: " + std::to_string(static_cast<int>(error)));
    }
}

void BTConnection::processHandshake() {
    // Simplified implementation
    if (m_receiveBufferPos >= 68) {
        m_handshakeReceived = true;
        m_receiveBufferPos = 0;
        
        // Send extension handshake
        sendExtensionHandshake();
    }
}

void BTConnection::sendExtensionHandshake() {
    // Simplified implementation
    std::vector<uint8_t> extensionMessage;
    
    // Add message to buffer
    std::shared_ptr<network::Buffer> buffer = std::make_shared<network::Buffer>(extensionMessage.size());
    std::memcpy(buffer->data(), extensionMessage.data(), extensionMessage.size());
    buffer->resize(extensionMessage.size());
    
    m_socket->send(buffer, [this](bool success, int bytesSent) {
        if (!success) {
            setState(BTConnectionState::Error, "Failed to send extension handshake");
        }
    });
}

void BTConnection::processMessage() {
    // Simplified implementation
}

void BTConnection::processExtensionMessage(const uint8_t* data, size_t size) {
    // Simplified implementation
}

void BTConnection::processUtMetadataMessage(const uint8_t* data, size_t size) {
    // Simplified implementation
}

void BTConnection::requestMetadataPiece(int piece) {
    // Simplified implementation
}

void BTConnection::processMetadataPiece(int piece, const uint8_t* data, size_t size) {
    // Simplified implementation
}

void BTConnection::checkMetadataComplete() {
    // Simplified implementation
}

void BTConnection::readNextMessage() {
    // Fixed version with correct callback signature
    m_socket->receive(m_receiveBuffer.size() - m_receiveBufferPos, 
        [this](bool success, std::shared_ptr<network::Buffer> buffer, int bytesReceived) {
            if (success && bytesReceived > 0) {
                // Copy data to our buffer
                if (m_receiveBufferPos + bytesReceived <= m_receiveBuffer.size()) {
                    std::memcpy(m_receiveBuffer.data() + m_receiveBufferPos, buffer->data(), bytesReceived);
                    m_receiveBufferPos += bytesReceived;
                    
                    // Process the received data
                    if (!m_handshakeReceived) {
                        processHandshake();
                    } else {
                        processMessage();
                    }
                } else {
                    setState(BTConnectionState::Error, "Receive buffer overflow");
                }
                
                // Continue reading
                readNextMessage();
            } else if (!success) {
                setState(BTConnectionState::Error, "Read failed");
            }
        });
}

} // namespace metadata
} // namespace dht_hunter
